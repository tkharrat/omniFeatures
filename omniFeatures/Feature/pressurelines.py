# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_pressurelines.ipynb.

# %% auto 0
__all__ = ['Pressureline_feature']

# %% ../nbs/01_pressurelines.ipynb 3
import pandas as pd
import numpy as np
import collections
import math 
from sklearn.cluster import KMeans

# %% ../nbs/01_pressurelines.ipynb 10
def _cluster(frame_df, n_clusters=3):

    #prepare the cluster output.
    def _input(frame_df, jerseyn_goal="1"):
        opponent_team = frame_df.iloc[0]["possessionSide"]
        cluster_input = frame_df.loc[:,
                                     frame_df.columns.str.startswith(
                                         (opponent_team))]
        cluster_input = cluster_input.loc[:,
                                          cluster_input.columns.str.endswith(
                                              ("_x", "_y"))]
        cluster_input = cluster_input.drop([
            opponent_team + "_player_" + jerseyn_goal + "_x",
            opponent_team + "_player_" + jerseyn_goal + "_y"
        ],
                                           axis=1)
        cluster_input = cluster_input.dropna(axis=1, how='all')

        #find players cols
        player_col = [
            item.replace("x", "player_id")
            for item in list(cluster_input.loc[:,
                                               cluster_input.columns.str.
                                               endswith('_x')].columns.values)
        ]
        player_ids = [frame_df.iloc[0][col] for col in player_col]

        cluster_input = np.reshape(cluster_input.values, (-1, 2))

        return cluster_input, player_ids

    #calculate the centroid of a cluster.
    def centeroid(coord: list) -> float:
        x, y = zip(*coord)
        l = len(x)
        return sum(x) / l, sum(y) / l

    #calculate distance between centroid & ball.
    def ball_dist(centroid_coord: list, ball_coord: list) -> float:
        return math.sqrt((ball_coord[0] - centroid_coord[0])**2 +
                         (ball_coord[1] - centroid_coord[1])**2)

    #sort the clusters according to the centroid closest to the ball.
    def sort_cluster(cluster_output, players_id):
        
        clt_pl = collections.defaultdict(list)
        clt_coord = collections.defaultdict(list)

        for x, y in zip(cluster_output, players_id):
            clt_pl[x].append(y)
        for x, y in zip(cluster_output, cluster_input):
            clt_coord[x].append(y)

        #calculate centeroid for each cluster
        clt_coord = dict(
            map(lambda coord: (coord[0], centeroid(coord[1])),
                clt_coord.items()))
        #calculate distance between centeroid & ball
        clt_coord = dict(
            map(
                lambda coord: (coord[
                    0], ball_dist(coord[1], [ball_coord[0], ball_coord[1]])),
                clt_coord.items()))
        #sort dict
        clt_coord = dict(sorted(clt_coord.items(), key=lambda item: item[1]))

        sorted_keys = list(clt_coord.keys())

        return [(",".join(clt_pl.get(sorted_keys[cluster_num])))
                for cluster_num in sorted_keys]

    #apply cluster on input
    def cluster_output(dataset, players_id, Vpl=True):
        X = np.array(dataset, copy=True)
        #vertical pressure lines
        if Vpl:
            X[:, 1] = 0
        #horizontal pressure lines
        else:
            X[:, 0] = 0

        km = KMeans(n_clusters)
        y_means = km.fit_predict(X)

        return sort_cluster(y_means, players_id)

    ball_coord = [frame_df.iloc[0]["ball_x"], frame_df.iloc[0]["ball_y"]]

    cluster_input, players_id = _input(frame_df)

    vpl_cluster = cluster_output(cluster_input, players_id)
    hpl_cluster = cluster_output(cluster_input, players_id, Vpl=False)

    return vpl_cluster, hpl_cluster

# %% ../nbs/01_pressurelines.ipynb 11
def Pressureline_feature(tracking: pd.DataFrame,
                         mapevents: pd.DataFrame) -> pd.DataFrame:

    df = pd.DataFrame()

    frame_ids = mapevents["frameId"].drop_duplicates().tolist()
    tracking_df = tracking[tracking['frameId'].isin(frame_ids)]

    for _, row in tracking_df.iterrows():
        frame_id = row["frameId"]
        frame_df = tracking[(tracking["frameId"] == frame_id)]
        if frame_df.iloc[0]["possessionSide"] != "unknown":
            vpl, hpl = _cluster(frame_df)

            row = dict(frameId=frame_id,
                       vPressureline1=vpl[0],
                       vPressureline2=vpl[1],
                       vPressureline3=vpl[2],
                       hPressureline1=hpl[0],
                       hPressureline2=hpl[1],
                       hPressureline3=hpl[2])
            df = pd.concat([df, pd.DataFrame([row])], ignore_index=True)

    return df
